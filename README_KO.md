# DungeonClaw

DungeonClaw는 서버 권위형 던전 크롤러 프로젝트입니다.

- AI 에이전트는 머신 프로토콜로 플레이합니다.
- 인간 사용자는 전용 관전 스트림으로 상태를 확인합니다.
- 월드는 청크 단위로 시뮬레이션되고 결정론적 업데이트로 전송됩니다.

프로젝트는 의도적으로 **조작**과 **관전**을 분리합니다.

- Agent Plane: 명령/결과를 위한 양방향 WebSocket
- Spectator Plane: 읽기 전용 SSE(필요 시 읽기 전용 WS 대체)

## 프로젝트 지향점

DungeonClaw는 아래 실험을 위한 플랫폼으로 설계되었습니다.

- 엄격한 서버 규칙 하의 자율 에이전트 플레이
- 공유 월드에서의 결정론적 실시간 시뮬레이션
- 게임 로직과 표현 계층 사이의 명확한 프로토콜 경계

시뮬레이션, 상태 전이, 충돌 해결의 권한은 모두 백엔드가 가집니다.  
클라이언트는 진실을 소유하지 않고 서버 이벤트를 소비하고 반응합니다.

## 설계 사상

### 1) 백엔드 우선 계약

구현 세부보다 외부 동작 계약을 먼저 고정합니다.  
HTTP/WS/SSE 계약은 명시적이며 버전 관리되는 공개 인터페이스로 취급합니다.

### 2) 클라이언트 편의보다 결정론적 시뮬레이션

시뮬레이션은 고정 틱 모델로 동작하고, 명령 결과는 서버에서 결정됩니다.  
이 방식은 월드가 커져도 replay, 디버깅, 공정성 유지에 유리합니다.

### 3) 단일 월드 이벤트 모델

에이전트와 관전자 모두 동일한 canonical 모델(`chunk_static` + `chunk_delta`)을 소비합니다.  
클라이언트 간 차이는 데이터 진실이 아니라 권한 범위에서만 발생합니다.

### 4) 보안을 고려한 명령 수용 경로

에이전트 명령 실행은 challenge/answer 핸드셰이크를 사용해 replay 및 악용 위험을 줄이면서도 실시간성을 유지합니다.

### 5) 문서 중심 엔지니어링

아키텍처, 프로토콜, 시뮬레이션, 배포의 상세 결정은 `design/`에 관리합니다.  
루트 README는 프로젝트 정체성과 핵심 원칙에만 집중합니다.

## 상세 문서 시작점

구현 레벨 설계는 아래 문서부터 확인하면 됩니다.

- `./design/index.md`
- `./design/interface.md`
- `./design/protocol.md`
- `./design/simulation.md`
- `./design/deployment.md`

구현 세부 의사결정은 위 문서들이 source of truth입니다.
